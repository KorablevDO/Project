package ru.test.lab.tasks;

import org.lib.tools.datasurce.StringRandomGenerator;
import org.testng.annotations.Test;

public class TestTasksCollections {
    /**
     * 1. Реализуйте алгоритм под названием "Решето Эратосфена" для выявления всех
     простых чисел меньше или равных п. Сначала введите все числа от 2 до п в множество.
     Затем организуйте повторяющийся поиск наименьшего элемента s в
     этом множестве, постепенно удаляя из него элементы s 2, s • ( s + 1), s • ( s + 2)
     и т.д. Этот поиск завершается при условии, когда s 2 > п. Реализуйте данный
     алгоритм как для множества типа HashSet<Integer>, так и для множества типа
     BitSet.
     */
    @Test
    public void sieveOfEratosthenes(){
        //TODO
    }

    /**
     * 2. Сделайте все буквы прописными в символьных строках, содержащихся в массиве.
     С этой целью воспользуйтесь сначала итератором, затем перебором индексных
     значений в цикле и, наконец, методом replaceAll ().
     */

    /**
     * 3. Как вычислить объединение, пересечение и разность двух множеств, используя
     только методы из интерфейса Set, но не организуя циклы?
     */

    /**
     * 4. Воспроизведите ситуацию, когда возникает исключение типа Concur г entModif
     icationException. Что можно предпринять, чтобы избежать этого?
     */

    /**
     * 5. Реализуйте метод public static void swap(List<?> list, int i, int j), выполняющий
     перестановку элементов обычным образом, когда класс, определяющий
     тип параметра list, реализует интерфейс RandomAccess, а иначе
     сводящий к минимуму обход элементов на позициях, обозначаемых индексами
     i и j.
     */

    /**
     * 6. В этой главе рекомендовалось пользоваться интерфейсами вместо конкретных
     классов структур данных, например, интерфейсом Мар вместо класса ТгееМар.
     К сожалению, подобная рекомендация не идет дальше этого. Почему нельзя,
     например, воспользоваться интерфейсом Map<String, Set<Integer», чтобы
     представить содержание документа? (Подсказка: как инициализировать его?)
     Каким типом структуры данных можно вместо этого воспользоваться?
     */

    /**
     * 7. Напишите программу для чтения всех слов из файла и вывода частоты, с которой
     каждое слово встречается в нем. Воспользуйтесь для этой цели классом
     TreeMap<String, IntegerX
     */

    /**
     * 8. Напишите программу для чтения всех слов из файла и вывода строк, в которых
     каждое слово встречается в нем. Воспользуйтесь для этой цели преобразованием
     из символьных срок в множества.
     */

    /**
     * 9. Счетчик в отображении счетчиков можно обновить следующим образом:
     counts.merge(word, 1, Integer::sum);
     Сделайте то же самое без метода merge (), воспользовавшись, во-первых, методом
     contains (); во-вторых, методом get () и проверкой пустых значений
     (null); в-третьих, методом getOrDefault () и, в-четвертых, методом putlf
     A b s e n t ().
     */

    /**
     * 10. Реализуйте алгоритм Дейкстры для поиска кратчайших путей между городами,
     связанными сетью автомобильных дорог. (Описание этого алгоритма можно
     найти в популярной литературе по алгоритмам или в соответствующей статье
     Википедии.) Воспользуйтесь вспомогательным классом Neighbor для хранения
     названия соседнего города и расстояния до него. Представьте полученный
     граф в виде преобразования названий городов в множества соседних городов.
     Воспользуйтесь в данном алгоритме классом PriorityQueue<Neighbor>.
     */

    /**
     * 11. Напишите программу для чтения предложения в списочный массив. Затем перетасуйте
     в массиве все слова, кроме первого и последнего, используя метод
     Collections. shuffle (), но не копируя слова в другую коллекцию.
     */

    /**
     * 12. Используя метод Collections . shuffle (), напишите программу для чтения
     предложения, перетасовки его слов и вывода результата. Устраните (до и после
     перетасовки) написание начального слова с заглавной буквы и наличие точки в
     конце предложения. Подсказка: не перетасовывайте при этом слова.
     */

    /**
     * 13. Всякий раз, когда в отображение типа LinkedHashMap вводится новый элемент,
     вызывается метод removeEldestEntry (). Реализуйте подкласс Cache, производный
     от класса LinkedHashMap и ограничивающий размер отображения заданной
     величиной, предоставляемой в конструкторе этого класса.
     */

    /**
     * 14. Напишите метод для получения неизменяемого представления списка чисел
     от 0 до п, не сохраняя эти числа.
     */

    /**
     * 15. Обобщите предыдущее упражнение произвольным функциональным
     интерфейсом Int Function. Имейте в виду, что в конечном итоге может
     получиться бесконечная коллекция, поэтому некоторые методы (например,
     size () и toArrayO) должны генерировать исключение типа
     UnsupportedOperationException.
     */

    /**
     * 16. Усовершенствуйте реализацию из предыдущего упражнения, организовав кеширование
     последних 100 значений, вычисленных функцией.
     */

    /**
     * 17. Покажите, каким образом проверяемое представление может сообщить о конкретной
     ошибке, ставшей причиной загрязнения "кучи".
     */

    /**
     * 18. В классе Collections имеются статические константы EMPTY_LIST, EMPTY_MAP и
     EMPTY_SET. Почему они не так полезны, как методы emptyList (), emptyMap () и
     emptySet ()?
     */
}
