10
Упражнения
1. Используя параллельные потоки данных, найдите в каталоге все файлы, содержащие
заданное слово. Как найти только первый файл? Действительно ли поиск
файлов осуществляется параллельно?
2. Насколько большим должен быть массив, чтобы метод A r r a y s . p a r a l l e l S o r t ()
выполнялся быстрее, чем метод A r r a y s . s o r t () на вашем компьютере?
3. Реализуйте метод, возвращающий задачу для чтения всех слов из файла с целью
найти в нем заданное слово. Если задача прерывается, она должна быть завершена
немедленно с выдачей отладочного сообщения. Запланируйте выполнение
этой задачи для каждого файла в каталоге. Как только одна из задач завершится
успешно, все остальные задачи должны быть немедленно прерваны.
4. В разделе 10.3.2 не была рассмотрена еще одна параллельная операция над
массивами. Она реализуется в методе p a r a l l e l P r e f i x () и заменяет каждый
элемент массива накоплением префикса для заданной ассоциативной операции.
В качестве примера рассмотрим массив [1, 2, 3, 4, ...] и операцию
х. После выполнения вызова A r r a y s . p a r a l l e l P r e f i x ( v a lu e s , (х, у) -> х * у)
массив содержит следующие элементы:
[1, 1 x 2 , 1 x 2 x 3 , 1 х 2 х з х 4, . . . ]
Как ни странно, подобное вычисление можно распараллелить. Сначала нужно
соединить смежные элементы, как показано ниже.
[1, 1 X 2, 3, 3 X 4, 5, 5 X б, 7, 7 X 8]
Значения, выделенные обычным шрифтом, не затрагиваются данной операцией.
Очевидно, что ее можно выполнить параллельно на отдельных участках
массива, а затем обновить выделенные выше полужирным элементы, перемножив
их с элементами, находящимися на одну или две позиции раньше, как
показано ниже.
[1, 1 x 2 , 1 x 2 x 3 , 1 х 2 х З х 4 , 5, 5 x 6 , 5 x 6 x 7 , 5 x 6 x 7 x 8 1
И эту операцию можно выполнить параллельно. После lo g (л) шагов процесс
будет завершен. Это более выгодный способ, чем простое линейное вычисление
при наличии достаточного количества процессоров.
Воспользуйтесь в данном упражнении методом p a r a l l e l P r e f i x (), чтобы распараллелить
вычисление чисел Фибоначчи, используя тот факт, что п-е число
Фибоначчи является левым верхним коэффициентом F", где F = ( J q). Создайте
массив, заполнив его матрицами 2x2. Определите класс M a t r i x с методом
умножения. Воспользуйтесь методом p a r a l l e l S e t A l l (), чтобы создать массив
матриц, а методом p a r a l l e l P r e f i x (), чтобы перемножить их.
5. Напишите прикладную программу, где в нескольких потоках исполнения читаются
все слова из совокупности файлов. Воспользуйтесь параллельным отображением
типа C o n c u r r e n t H a s h M a p < S t r in g , S e t < F i l e > > для отслеживания
файлов, в которых встречается каждое слово, а методом m e rge () — для обновления
данного отображения.
6. Повторите предыдущее упражнение, но на этот раз воспользуйтесь методом
c o m p u t e lf A b s e n t ( ) . В чем преимущество такого подхода?
7. Найдите в отображении типа C o n c u r r e n t H a s h M a p < S t r in g , L o n g > ключ с максимальным
значением, произвольно отбрасывая лишнее. Подсказка: воспользуйтесь
методом r e d u c e E n t r ie s ().
8. Сформируйте 1000 потоков исполнения, в которых счетчик инкрементируется
100000 раз. Сравните производительность при использовании классов
A to m ic L o n g и L o n g A d d e r.
9. Воспользуйтесь классом LongAccumulator для вычисления максимального и
минимального накапливаемых элементов.
10. Воспользуйтесь блокирующей очередью для обработки файлов в каталоге.
В одном потоке исполнения организуйте обход дерева каталога и ввод файлов
в очередь, а в нескольких потоках исполнения — удаление файлов и поиск в
каждом из них заданного ключевого слова с выводом любых совпадений. Как
только задача поставщика будет завершена, в очередь должен быть введен фиктивный
файл.
11. Повторите предыдущее упражнение, но на этот раз сформируйте в задаче
потребителя отображение слов и частоты, с которой они вводятся во вторую
очередь. В последнем потоке исполнения полученные словари должны быть
объединены, а затем выведены десять наиболее употребительных слов. Почему
для этой цели не потребуется отображение типа C o n c u r re n tH a s h M a p ?
12. Повторите предыдущее упражнение, создав объект типа C a l la b le < M a p < S t r in g ,
I n t e g e r > > для каждого файла и воспользовавшись подходящей службой
исполнителя. Объедините полученные результаты, как только все они будут
доступны. Почему для этой цели не потребуется отображение типа
C o n c u rre n tH a sh M a p ?
13. Повторите предыдущее упражнение, воспользовавшись на этот раз интерфейсом
E x e c u t o r C o m p le t io n S e r v ic e и объединив полученные результаты, как
только все они будут доступны.
14. Повторите предыдущее упражнение, воспользовавшись глобальным отображением
типа C o n c u r re n tH a sh M a p для накопления частоты, с которой встречается
каждое слово.
15. Повторите предыдущее упражнение, воспользовавшись параллельными потоками
данных. Ни одна из потоковых операций не должна иметь никаких побочных
эффектов.
16. Напишите программу для обхода дерева каталогов с формированием отдельного
потока исполнения для каждого файла. Подсчитайте в потоках исполнения
количество слов в файлах и, не прибегая к блокировкам, обновите общий
счетчик, который объявляется следующим образом:
public static long count = 0;
Выполните эту программу неоднократно. Что при этом происходит и почему?
17. Усовершенствуйте программу из предыдущего упражнения, используя блокировки.
18. Усовершенствуйте программу из предыдущег
public void add(Object newValue) {
Node n = new Node();
if (head == null) head = n;
else tail.next = n;
tail = n;
tail.value = newValue;
}
public Object remove() {
if (head == null) return null;
Node n = head;
head = n.next;
return n.value;
}
}
21. Опишите два разных пути, приводящих к тому, что данная структура данных
может содержать неверные элементы.
22. Найдите ошибку в следующем фрагменте кода:
public class Stack {
private Object myLock = "LOCK";
public void push(Object newValue) {
synchronized (myLock) {
}
}
}
23. Найдите ошибку в следующем фрагменте кода:
public class Stack {
public void push(Object newValue) {
synchronized (new ReentrantLock()) {
}
}
}
24. Найдите ошибку в следующем фрагменте кода:
public class Stack {
private Object[] values = new Object[10];
private int size;
public void push(Object newValue) {
synchronized (values) {
if (size == values.length)
values = Arrays.copyOf(values, 2 * size);
values[size] = newValue;
size++;
}
}
}
25. Напишите программу, запрашивающую у пользователя URL, читающую
веб-страницу по этому URL и выводящую на экран все ссылки на ней. Воспользуйтесь
для каждой из этих стадий классом C o m p le ta b le F u t u r e . Только не
вызывайте метод g e t ( ) . Чтобы не допустить преждевременного прекращения
работы данной программы, сделайте следующий вызов:
ForkJoinPool.commonPool().awaitQuiescence(10, TimeUnit.SECONDS);
26. Напишите следующий метод:
public static <T> CompletableFuture<T> repeat(
Supplier<T> action, Predicate<T> until)
Этот метод должен асинхронно повторять заданное действие до тех пор, пока
не будет получено значение, принимаемое функцией u n t i l (), которая также
должна выполняться асинхронно. Проверьте этот метод с помощью одной
функции, вводящей объект типа j a v a . n e t . P a s s w o r d A u t h e n t ic a t io n с консоли,
и другой функции, имитирующей проверку достоверности, ожидая в течение
секунды и затем проверяя пароль " s e c r e t " . Подсказка: воспользуйтесь рекурсией.





